package com.hazelcast.sqlclient.jdbc;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

import net.sf.jsqlparser.JSQLParserException;
import net.sf.jsqlparser.statement.insert.Insert;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import com.hazelcast.sqlclient.executor.Executor;
import com.hazelcast.sqlclient.executor.HazelcastExecutor;
import com.hazelcast.sqlclient.type.DataType;
import com.hazelcast.sqlclient.type.SqlKind;
import com.hazelcast.sqlclient.utility.IMDGString;
import com.hazelcast.sqlclient.utility.ThreadPool;

public class IMDGPreparedStatement implements java.sql.PreparedStatement{
	private static ConcurrentHashMap<String, ArrayList<String>> arguMap = new ConcurrentHashMap<String, ArrayList<String>>(100);
	private static ConcurrentHashMap<String, Integer> updateSetArguNumMap = new ConcurrentHashMap<String, Integer>(100);
	
	BatchParams batchParams =  null;
	private static int batchThreadNum = 1;
	private int blockSize;
	private HashMap<String, ArrayList<String>> arguValueListMap = null;
	protected String[] originalSql = null;
//	protected boolean[] isNull = null;
//	protected String[] parameterStrings = null;
	protected Statement dbst = null;
	protected ResultSetMetaData rsmd = null;
	// parse sql sentence
	protected boolean parseflag = false;
	protected String sqlsentence = null;
	protected int argucnt = 0;
	protected ArrayList<String> arguNameList = null;
	protected ArrayList<String> arguValueList = new ArrayList<String>();
	// for update sql
	protected Integer setargunum = null;
	protected ArrayList<String> updatesetArguList = null;
	protected ArrayList<String> updatewhereArguList = null;
	// sql type and whether supported or not
	protected SqlKind sqlkind;
	protected boolean supportedornot = true;
	
	// temporary code to decouple IMDGPreparedStatement from IMDGStatement
	protected Executor hzExecutor = new HazelcastExecutor();
	protected IMDGResultSet hzrs = null;
	protected int updateCount = -1;
	protected boolean closed = false;
	protected Connection connection = null;
	
	protected int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;
	protected int resultSetType = ResultSet.TYPE_FORWARD_ONLY;
	protected int autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
	protected boolean isReadOnly = false;
	
	// for unsupported sql ResultSet
	protected ResultSet dbrs = null;
	private static HazelcastInstance hazelcast = null;
	
	//TODO: statement --> preparedStatement
	public IMDGPreparedStatement(String sql, Connection c, Statement statement, SqlKind kind, int autoGeneratedKeys) throws SQLException {
		sql = sql.toLowerCase();
		System.out.println(sql);
		//IMDGLog.showSql(sql);
		//jiang yong 2014-11-2 for query result cache
		if((hazelcast = Hazelcast.getHazelcastInstanceByName("IMDG")) == null) {
			Config config = new Config();
			config.setInstanceName("IMDG");
			hazelcast = Hazelcast.newHazelcastInstance(config);
		}
		//added done
		sqlsentence = sql;
		connection = c;
		// for unsupported sql
		if(statement != null) {
			dbst = statement;
			supportedornot = false;
		}
		sqlkind = kind;
		this.autoGeneratedKeys = autoGeneratedKeys;
		// for select sql
		if(sqlkind == SqlKind.SELECT || sqlkind == SqlKind.INSERT) {
			hzrs = new IMDGResultSet(this);
		}
		
		if (supportedornot) {
			arguNameList = checkSQLParsed(sql);
//			System.out.println("------arguNameList1-----");
//			for(int i = 0; i < arguNameList.size(); i++){
//				System.out.println(arguNameList.get(i));
//			}
//			System.out.println("------arguNameList1-----");
			if(arguNameList != null) {
				argucnt = arguNameList.size();
				arguValueList.clear();
				for(int i = 0; i < argucnt; ++i) {
					arguValueList.add(null);
				}
				if(cachedSQL(sql)) {
					parseflag = true;
//					return;
				}
			}
		}

		sql = sql.trim();
		if (sql.endsWith("?")) {
			sql = sql + " ";
		}
		originalSql = sql.split("\\?");
		if (originalSql.length > 1) {
			arguValueList.clear();
			argucnt = originalSql.length - 1;
			for (int i = 0; i < argucnt; i++) {
				arguValueList.add(null);
			}
		}
		
		//IMDGLog.showInfo("PreparedStatement Start");
	}
	
	private void addArgument(String key, ArrayList<String> names, int num, Boolean updateflag) {
		arguMap.put(key, names);
		// update condition: count the arguments in the set clause
		if(updateflag) {
			updateSetArguNumMap.put(key, new Integer(num));
		}
	}
	
	//jiang yong 2014-12-12
	public void addBatch() throws SQLException {
		if (batchParams == null) {
			batchParams = new BatchParams(sqlkind, sqlsentence, arguNameList);
		}
		batchParams.addArguValueList(arguValueList);
	}
	
	public void addBatch(String sql) throws SQLException {
		throw new SQLException("addBatch(String sql) Not Implemented.");
	}
	
	// check cached or not by shuping
	private boolean cachedSQL(String sql) throws SQLException {
		//sql.toLowerCase?
		//sql = sql.toLowerCase();
		switch (sqlkind) {
		case SELECT:
			return hzExecutor.whetherSelectCached(sql);
		case INSERT:
			return hzExecutor.whetherInsertCached(sql);
		case DELETE:
			return hzExecutor.whetherDeleteCached(sql);
		case UPDATE:
			return hzExecutor.whetherUpdateCached(sql);
		default:
			throw new SQLException("cachedSQL(): Unknow SQL Type");
		}
	}
	public void cancel() throws SQLException {
	}

	protected void checkClosed() throws SQLException {
		if (this.closed) {
			throw new SQLException("SQL_STATE_CONNECTION_NOT_OPEN");
		}
	}
	
	private void CheckParamIndex(int paramIndex) throws SQLException {
		if(paramIndex < 1 || paramIndex > argucnt) {
			throw new SQLException("ilegal parameter index");
		}
	}
	
	private ArrayList<String> checkSQLParsed(String sql) throws SQLException{
		ArrayList<String> tmp = arguMap.get(sql);
		if (tmp == null) {
			switch (sqlkind) {
			case SELECT:
				addArgument(sql, parseSelectSQL(sql), -1, false);
				break;
			case INSERT:
				addArgument(sql, parseInsertSQL(sql), -1, false);
				break;
			case DELETE:
				addArgument(sql, parseDeleteSQL(sql), -1, false);
				break;
			case UPDATE:
				ArrayList<String> tmpList = new ArrayList<String>();
				int setargunum = parseUpdateSQL(sql, tmpList);
				addArgument(sql, tmpList, setargunum, true);
				break;
			default:
				throw new SQLException("supportedCheck(): Unknow SQL Type");
			}
		}
		return ((tmp == null) ? arguMap.get(sql) : tmp);
	}
	
	protected void clear() throws SQLException {
		if (hzrs != null) {
			hzrs.clear();
		}
		updateCount = -1;
	}
	
	
	public void clearBatch() throws SQLException {
		if(batchParams != null){
			batchParams.clear();
		}
		batchParams = null;
		if(!supportedornot){
			dbst.clearBatch();
		}
	}
	
	public void clearParameters() throws SQLException {
		arguValueList.clear();
		for (int i = 0; i < argucnt; i++) {
			arguValueList.add(null);
		}
	}
	
	public void clearWarnings() throws SQLException {
	}
	
	public void close() throws SQLException {
		closed = true;
		if (dbst != null) {
			dbst.close();
			dbst = null;
		}
		// 娑撳秹娓剁憰涓剅rayList閻ㄥ垻lear閹垮秳缍�
		if(hzrs != null) {
			hzrs.close();
		}
		originalSql = null;
		rsmd = null;
		// parse sql sentence
		sqlsentence = null;
		arguNameList = null;
		arguValueList = null;
		// for update sql
		updatesetArguList = null;
		updatewhereArguList = null;
		// temporary code to uncouple IMDGPreparedStatement from IMDGStatement
		hzExecutor = null;
		hzrs = null;
		connection = null;
		updateCount = -1;
	}
	
	// DataBase Execute Delete for unsupported SQL
	protected int DBExecuteDelete(String sql) throws SQLException {
		updateCount = dbst.executeUpdate(sql);
		return updateCount;
	}
	
	// DataBase Execute Insert for unsupported SQL
	protected int DBExecuteInsert(String sql) throws SQLException {
		if(autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
//			updateCount = dbst.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
//			ResultSet rsSet = dbst.getGeneratedKeys();
//			ResultSetMetaData rsData = rsSet.getMetaData();
//			ArrayList<String> namesList = new ArrayList<String>();
//			ArrayList<String> typeNameList = new ArrayList<String>();
//			ArrayList<String> colsTabList = new ArrayList<String>();
//			ArrayList<String> colsDBList = new ArrayList<String>();
//			ArrayList<List<Object> > colsValueList = new ArrayList<List<Object> >();
//			
//			int columncount = rsData.getColumnCount();
//			for (int i = 1; i <= columncount; i++) {
//				namesList.add(rsData.getColumnName(i));
//				typeNameList.add(rsData.getColumnClassName(i));
//				colsTabList.add(rsData.getTableName(i));
//				colsDBList.add(rsData.getCatalogName(i));
//			}
//			hzrs.addMetaData(namesList, typeNameList, colsTabList, colsDBList);
//			while (rsSet.next()) {
//				ArrayList<Object>  rowlist = new ArrayList<Object>();
//				columncount = rsData.getColumnCount();
//				for (int i = 1; i <= columncount; i++) {
//					rowlist.add(rsSet.getObject(i));
//				}
//				colsValueList.add((List<Object>)rowlist);
//			}
//			hzrs.addRowValueData(colsValueList);
//			hzrs.checkResult();
//			rsSet.close();
			
			updateCount = dbst.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
			dbrs = dbst.getGeneratedKeys();
			hzrs.clear();
			hzrs.closed = true;
		} else {
			updateCount = dbst.executeUpdate(sql);
		}
		return updateCount;
	}
	
	// complex sql throwed into DB to execute
	protected void DBExecuteQuery(String sql) throws SQLException {
//		ResultSet rsSet = dbst.executeQuery(sql);
//		ResultSetMetaData rsData = rsSet.getMetaData();
//		ArrayList<String> namesList = new ArrayList<String>();
//		ArrayList<String> typeNameList = new ArrayList<String>();
//		ArrayList<String> colsTabList = new ArrayList<String>();
//		ArrayList<String> colsDBList = new ArrayList<String>();
//		ArrayList<List<Object> > colsValueList = new ArrayList<List<Object> >();
//
//		int columncount = rsData.getColumnCount();
//		for (int i = 1; i <= columncount; i++) {
//			String columnName = rsData.getColumnName(i);
//			namesList.add(columnName);
//
//			String className = rsData.getColumnClassName(i);
//			typeNameList.add(className);
//
//			colsTabList.add(rsData.getTableName(i));
//			colsDBList.add(rsData.getCatalogName(i));
//		}
//		hzrs.addMetaData(namesList, typeNameList, colsTabList, colsDBList);
//		while (rsSet.next()) {
//			ArrayList<Object>  rowlist = new ArrayList<Object>();
//			columncount = rsData.getColumnCount();
//			for (int i = 1; i <= columncount; i++) {
//				rowlist.add(rsSet.getObject(i));
//			}
//			colsValueList.add((List<Object>)rowlist);
//		}
//		hzrs.addRowValueData(colsValueList);
//		hzrs.checkResult();
//		rsSet.close();
//		System.out.println("DBExecutor: " + sql);
		dbrs = dbst.executeQuery(sql);
		hzrs.clear();
		hzrs.closed = true;
	}
	
	// DataBase Execute Update for unsupported SQL
	protected int DBExecuteUpdate(String sql) throws SQLException {
		updateCount = dbst.executeUpdate(sql);
		return updateCount;
	}

	
	@SuppressWarnings("unused")
	private void debugInfo() {
		System.err.println("*****************************************************************************");
		System.err.println("Cached SQL:" + sqlsentence);
		for (int i = 1; i <= argucnt; i++) {
			System.err.println("[" + arguNameList.get(i-1) + ":" + arguValueList.get(i-1) + "]");
		}
		System.err.println("*****************************************************************************");
	}

	//TODO: executeQuery + executeUpdate
	public boolean execute() throws SQLException {
		throw new SQLException("execute() Not Implemented.");
//		System.out.println("execute() =============" + sqlsentence);
		//IMDGLog.showInfo("execute()");
//		checkClosed();
//		clear(); // must!!
//		if(parseflag) {
////			debugInfo();
//			switch (sqlkind) {
//			case SELECT:
//				hzExecutor.executeSelectCache(sqlsentence, arguNameList, arguValueList, hzrs);
//				hzrs.checkResult();
//				return true;
//			case INSERT:
//				hzExecutor.executeInsertCache(sqlsentence, arguNameList, arguValueList, hzrs);
//				hzrs.checkResult();
//				return false;
//			case DELETE:
//				updateCount = hzExecutor.executeDeleteCache(sqlsentence, arguNameList, arguValueList);
//				return false;
//			case UPDATE:
//				if(setargunum == null) {
//					setargunum = IMDGPreparedStatement.updateSetArguNumMap.get(sqlsentence);
//				}
//				if(updatesetArguList == null) {
//					updatesetArguList = new ArrayList<String>(arguNameList.subList(0, setargunum));
//					updatewhereArguList = new ArrayList<String>(arguNameList.subList(setargunum, arguNameList.size()));
//				}
//				ArrayList<String> updatesetValueList = new ArrayList<String>(arguValueList.subList(0, setargunum));
//				ArrayList<String> updatewhereValueList = new ArrayList<String>(arguValueList.subList(setargunum, arguValueList.size()));
//				updateCount = hzExecutor.executeUpdateCache(sqlsentence, updatesetArguList, updatesetValueList, updatewhereArguList, updatewhereValueList);
//				return false;
//			default:
//				throw new SQLException("Unknow SQL Type");
//			}
//		} else {
//			String sql = SQLConcat();
//			switch (sqlkind) {
//			case SELECT:
//				if (supportedornot) {
//					hzExecutor.executeSelectPre(sqlsentence, sql, hzrs);
//					hzrs.checkResult();
//					parseflag = true;
//				} else {
//					DBExecuteQuery(sql);
//				}
//				return true;
//			case INSERT:
//				if (supportedornot) {
//					updateCount = hzExecutor.executeInsertPre(sqlsentence, sql, hzrs);
//					hzrs.checkResult();
//					parseflag = true;
//				} else {
//					DBExecuteInsert(sql);
//				}
//				return false;
//			case DELETE:
//				if (supportedornot) {
//					updateCount = hzExecutor.executeDeletePre(sqlsentence, sql);
//					parseflag = true;
//				} else {
//					DBExecuteDelete(sql);
//				}
//				return false;
//			case UPDATE:
//				if (supportedornot) {
//					updateCount = hzExecutor.executeUpdatePre(sqlsentence, sql);
//					parseflag = true;
//				} else {
//					DBExecuteUpdate(sql);
//				}
//				return false;
//			default:
//				throw new SQLException("Unknow SQL Type");
//			}
//		}
	}
	
	public boolean execute(String sql) throws SQLException {
		throw new SQLException("execute(String sql) Not Implemented.");
		// MySQL Connector: this function can return more than one resultset
		// they can be fetched by invoking getMoreResult()
		// not supported yet now
		// attention: before doing any insert delete update or select operation,
		// must clear the old data
		//IMDGLog.showInfo("execute(String sql)");
//		checkClosed();
//		clear(); // must!!
//		//?? judge
//		sql = sql.toLowerCase();
//		SqlKind kind = hzExecutor.judgeSQLKind(sql);
//		switch (kind) {
//		case SELECT:
//			if(hzrs == null) {
//				hzrs = new IMDGResultSet(this);
//			}
//			if (hzExecutor.supportedSelect(sql)) {
//				hzExecutor.executeSelect(sql, hzrs);
//				hzrs.checkResult();
//			} else {
//				DBExecuteQuery(sql);
//			}
//			return true;
//		case INSERT:
//			if(hzrs == null) {
//				hzrs = new IMDGResultSet(this);
//			}
//			// need to distinguish Statement.RETURN_G
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeInsert(sql, hzrs);
//				hzrs.checkResult();
//			} else {
//				DBExecuteInsert(sql);
//			}
//			return false;
//		case DELETE:
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeDelete(sql);
//			} else {
//				DBExecuteDelete(sql);
//			}
//			return false;
//		case UPDATE:
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeUpdate(sql);
//			} else {
//				DBExecuteUpdate(sql);
//			}
//			return false;
//		default:
//			throw new SQLException("Unknow SQL Type");
//		}
	}
	
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		throw new SQLException("execute(String sql, int autoGeneratedKeys) Not Implemented.");
		//IMDGLog.showInfo("execute(String sql, int autoGeneratedKeys)");
//		checkClosed();
//		clear(); // must!!
//		sql = sql.toLowerCase();
//		//??judge
//		SqlKind kind = hzExecutor.judgeSQLKind(sql);
//		switch (kind) {
//		case SELECT:
//			if(hzrs == null) {
//				hzrs = new IMDGResultSet(this);
//			}
//			if (hzExecutor.supportedSelect(sql)) {
//				hzExecutor.executeSelect(sql, hzrs);
//				hzrs.checkResult();
//			} else {
//				DBExecuteQuery(sql);
//			}
//			return true;
//		case INSERT:
//			if(hzrs == null) {
//				hzrs = new IMDGResultSet(this);
//			}
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeInsert(sql, hzrs);
//				hzrs.checkResult();
//			} else {
//				this.autoGeneratedKeys = autoGeneratedKeys;
//				DBExecuteInsert(sql);
//			}
//			return false;
//		case DELETE:
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeDelete(sql);
//			} else {
//				DBExecuteDelete(sql);
//			}
//			return false;
//		case UPDATE:
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeUpdate(sql);
//			} else {
//				DBExecuteUpdate(sql);
//			}
//			return false;
//		default:
//			throw new SQLException("Unknow SQL Type");
//		}
	}
	
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		// too complex
		//IMDGLog.showInfo("execute(String sql, int[] columnIndexes)");
		throw new SQLException("execute(String sql, int[] columnIndexes) Not Implemented.");
	}

	
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		// 閺佹壆绮嶉幐鍥┿仛閻ㄥ嫮娲伴弽鍥�娑擃厽瀵氱�姘辨畱閼奉亜濮╅悽鐔稿灇閻ㄥ嫬鍨惔鏃囶嚉閸欘垳鏁ゆ禍搴ゅ箯閸欙拷
		//IMDGLog.showInfo("execute(String sql, String[] columnNames)");
		throw new SQLException("execute(String sql, String[] columnNames) Not Implemented.");
	}

	
	public int[] executeBatch() throws SQLException {
		checkClosed();
//		clear();
		sqlkind = batchParams.getSqlKind();
		sqlsentence = batchParams.getSqlSentence();
		arguNameList = batchParams.getArguNameList();
		arguValueListMap = batchParams.getArguValueListMap();
		if(supportedornot){
			hzExecutor.executeBatchPre(sqlkind, sqlsentence);
			ExecutorService executor = ThreadPool.getInstance().getExecutor();
			blockSize = arguValueListMap.size()/batchThreadNum + 1;
			ArrayList<Future<?>> futureList = new ArrayList<Future<?>>();
			for(int i=0; i<batchThreadNum; i++){
				Runnable executeBatchSubTask = new ExecuteBatchSubTask(i);
				futureList.add(executor.submit(executeBatchSubTask));
			}
			for(int j=0; j<futureList.size(); j++){
				try {
					futureList.get(j).get();
				} catch (InterruptedException e) {
					e.printStackTrace();
				} catch (ExecutionException e) {
					e.printStackTrace();
				}
			}
		}
		//TODO: db executeBatch() 
		else{
			for(int i=1; i<=arguValueListMap.size(); i++){
				arguValueList = arguValueListMap.get(IMDGString.BATCHKEY + i);
				String sql = SQLConcat();
				dbst.addBatch(sql);
			}
			dbst.executeBatch();
//			switch(sqlkind){
//			case INSERT:
//				for(int i = 1; i <= arguValueListMap.size(); i++){
//					clear();
//					arguValueList = arguValueListMap.get(IMDGString.BATCHKEY + i);
//					String sql = SQLConcat();
//					DBExecuteInsert(sql);
//				}
//				break;
//			case DELETE:
//				for(int i = 1; i <= arguValueListMap.size(); i++){
//					clear();
//					arguValueList = arguValueListMap.get(IMDGString.BATCHKEY + i);
//					String sql = SQLConcat();
//					DBExecuteDelete(sql);
//				}
//				break;
//			case UPDATE:
//				for(int i = 1; i <= arguValueListMap.size(); i++){
//					clear();
//					arguValueList = arguValueListMap.get(IMDGString.BATCHKEY + i);
//					String sql = SQLConcat();
//					DBExecuteUpdate(sql);
//				}
//				break;
//			default:
//				throw new SQLException("Unknow SQL Type");
//			}
		}
		return null;
	}

	//jiang yong 2014-11-2 for query result cache
	public IMDGResult resultSetToResult(IMDGResultSet imdgResultSet){
		IMDGResult imdgResult = new IMDGResult();
//		imdgResult.setImdgResultInfo(true);
		imdgResult.resultCols = imdgResultSet.resultCols;
		imdgResult.resultRows = imdgResultSet.resultRows;
		imdgResult.resultCurrent = imdgResultSet.resultCurrent;
		imdgResult.lastRead = imdgResultSet.lastRead;
		for(Map.Entry<String, Integer> entry: imdgResultSet.colsNameMap.entrySet()){
			imdgResult.colsNameMap.put(entry.getKey(), entry.getValue());
		}
		for(DataType.Type colsType : imdgResultSet.colsTypeList){
			imdgResult.colsTypeList.add(colsType);
		}
		for(String colsTab : imdgResultSet.colsTabList){
			imdgResult.colsTabList.add(colsTab);
		}
		for(String colsDB: imdgResultSet.colsDBList){
			imdgResult.colsDBList.add(colsDB);
		}
		for(int i = 0; i < imdgResultSet.colsValuesList.size(); i++){
			imdgResult.colsValuesList.add(new ArrayList<Object>());
			ArrayList<Object> rowlist = imdgResultSet.colsValuesList.get(i);
			for(int j = 0; j < rowlist.size(); j++){
				imdgResult.colsValuesList.get(i).add(rowlist.get(j));
			}
		}
		return imdgResult;
	}
	
	public IMDGResultSet resultToResultSet(IMDGResult imdgResult){
		try{
			IMDGResultSet imdgResultSet = new IMDGResultSet(this);
			imdgResultSet.resultCols = imdgResult.resultCols;
			imdgResultSet.resultRows = imdgResult.resultRows;
			imdgResultSet.resultCurrent = imdgResult.resultCurrent;
			imdgResultSet.lastRead = imdgResult.lastRead;
			for(Map.Entry<String, Integer> entry: imdgResult.colsNameMap.entrySet()){
				imdgResultSet.colsNameMap.put(entry.getKey(), entry.getValue());
			}
			for(DataType.Type colsType : imdgResult.colsTypeList){
				imdgResultSet.colsTypeList.add(colsType);
			}
			for(String colsTab : imdgResult.colsTabList){
				imdgResultSet.colsTabList.add(colsTab);
			}
			for(String colsDB: imdgResult.colsDBList){
				imdgResultSet.colsDBList.add(colsDB);
			}
			for(int i = 0; i < imdgResult.colsValuesList.size(); i++){
				imdgResultSet.colsValuesList.add(new ArrayList<Object>());
				ArrayList<Object> rowlist = imdgResult.colsValuesList.get(i);
				for(int j = 0; j < rowlist.size(); j++){
					imdgResultSet.colsValuesList.get(i).add(rowlist.get(j));
				}
			}
			return imdgResultSet;
		}catch(SQLException e){
			e.printStackTrace();
			return null;
		}
	}
	
	public IMDGResult dbResultSetToIMDGResult(ResultSet dbResultSet){
		try{
			IMDGResult imdgResult = new IMDGResult();
//			imdgResult.setImdgResultInfo(true);
			ResultSetMetaData rsData = dbResultSet.getMetaData();
			ArrayList<String> namesList = new ArrayList<String>();
			ArrayList<String> typeNameList = new ArrayList<String>();
			ArrayList<String> colsTabList = new ArrayList<String>();
			ArrayList<String> colsDBList = new ArrayList<String>();
			ArrayList<List<Object> > colsValueList = new ArrayList<List<Object> >();

			int columncount = rsData.getColumnCount();
			for (int i = 1; i <= columncount; i++) {
				String columnName = rsData.getColumnName(i).toUpperCase();
				namesList.add(columnName);

				String className = rsData.getColumnClassName(i).toUpperCase();
				typeNameList.add(className);

				colsTabList.add(rsData.getTableName(i).toUpperCase());
				colsDBList.add(rsData.getCatalogName(i).toUpperCase());
			}
			imdgResult.addMetaData(namesList, typeNameList, colsTabList, colsDBList);
			while (dbResultSet.next()) {
				ArrayList<Object>  rowlist = new ArrayList<Object>();
				columncount = rsData.getColumnCount();
				for (int i = 1; i <= columncount; i++) {
					rowlist.add(dbResultSet.getObject(i));
				}
				colsValueList.add((List<Object>)rowlist);
			}
			imdgResult.addRowValueData(colsValueList);
			imdgResult.checkResult();
			dbResultSet.close();
			return imdgResult;
		}catch(SQLException e){
			e.printStackTrace();
			return null;
		}
		
	}
	public ResultSet executeQuery() throws SQLException{
		//IMDGLog.showInfo("executeQuery");
		if(hzExecutor.getCacheSwitch().equals("false")){
			return executeQueryNoQueryCache();
		}
		else{
			if(hzExecutor.supportedQueryResultCache(sqlsentence)){
				checkClosed();
				clear();
				IMap<String, IMDGResult> map = hazelcast.getMap(IMDGString.SQLTOCACHE);
				map.setEnabled(false);
				String sql = SQLConcat();
				if(map.containsKey(sql)){
//					System.out.println("cached: " +  sql);
					IMDGResult rst = map.get(sql);
					return resultToResultSet(rst);
				}
				else{
					if(parseflag){
						int tmp = hzExecutor.executeSelectCache(sqlsentence, arguNameList, arguValueList, hzrs);
						hzrs.checkResult();
						if(tmp == 0) {
							map.put(sql, resultSetToResult(hzrs));
							return hzrs;
						} else {
							throw new SQLException("executeQuery(): wrong result returned");
						}
					}
					else{
						if (supportedornot) {
							hzExecutor.executeSelectPre(sqlsentence, sql, hzrs);
							hzrs.checkResult();
							parseflag = true;
							map.put(sql, resultSetToResult(hzrs));
							return hzrs;
						} else {
							DBExecuteQuery(sql);
							map.put(sql, dbResultSetToIMDGResult(dbrs));
//							return dbrs;
							IMDGResult rst = map.get(sql);
							return resultToResultSet(rst);
						}
					}//parseflag end
				}//map.containsKey(sql) end
			} 
			else{
				return executeQueryNoQueryCache();
			}//supportedQueryResultCache(sqlsentence) end
		}//getCacheSwitch().equals("false") end
	}
	
	public ResultSet executeQueryNoQueryCache() throws SQLException {
		checkClosed();
		clear();
//		System.out.println("------arguValueList1-----");
//		for(int i = 0; i < arguValueList.size(); i++){
//			System.out.println(arguValueList.get(i));
//		}
//		System.out.println("------arguValueList1-----");
		if(parseflag) {
//			debugInfo();
			int tmp = hzExecutor.executeSelectCache(sqlsentence, arguNameList, arguValueList, hzrs);
			hzrs.checkResult();
			if(tmp == 0) {
				return hzrs;
			} else {
				throw new SQLException("executeQuery(): wrong result returned");
			}
		} else {
			String sql = SQLConcat();
			if (supportedornot) {
				hzExecutor.executeSelectPre(sqlsentence, sql, hzrs);
				hzrs.checkResult();
				parseflag = true;
				return hzrs;
			} else {
				DBExecuteQuery(sql);
				return dbrs;
			}
			
		}
	}
	//jiang yong done
	public ResultSet executeQuery_backup() throws SQLException {
		checkClosed();
		clear();
		if(parseflag) {
//			debugInfo();
			int tmp = hzExecutor.executeSelectCache(sqlsentence, arguNameList, arguValueList, hzrs);
			hzrs.checkResult();
			if(tmp == 0) {
				return hzrs;
			} else {
				throw new SQLException("executeQuery(): wrong result returned");
			}
		} else {
			String sql = SQLConcat();
			if (supportedornot) {
				hzExecutor.executeSelectPre(sqlsentence, sql, hzrs);
				hzrs.checkResult();
				parseflag = true;
				return hzrs;
			} else {
				DBExecuteQuery(sql);
				return dbrs;
			}
			
		}
	}
	// temporary code to decouple IMDGPreparedStatement from IMDGStatement
	public ResultSet executeQuery(String sql) throws SQLException {
//		checkClosed();
//		clear(); // must!!
//		sql = sql.toLowerCase();
//		if(hzrs == null) {
//			hzrs = new IMDGResultSet(this);
//		}
//		if (hzExecutor.supportedSelect(sql)) {
//			hzExecutor.executeSelect(sql, hzrs);
//			hzrs.checkResult();
//		} else {
//			DBExecuteQuery(sql);
//			return dbrs;
//		}
//		return hzrs;
		throw new SQLException("executeQuery(String sql) Not Implemented.");
	}

	
	public int executeUpdate() throws SQLException {
//		System.out.println("------arguValueList1-----");
//		for(int i = 0; i < arguValueList.size(); i++){
//			System.out.println(arguValueList.get(i));
//		}
//		System.out.println("------arguValueList1-----");
		//IMDGLog.showInfo("executeUpdate");
		// invoke statement's method
//		System.out.println("executeUpdate() =============" + sqlsentence);
		checkClosed();
		clear(); // must!!
		if(parseflag) {
//			debugInfo();
			switch (sqlkind) {
			case INSERT:
				updateCount = hzExecutor.executeInsertCache(sqlsentence, arguNameList, arguValueList, hzrs);
				hzrs.checkResult();
				return updateCount;
			case DELETE:
				updateCount = hzExecutor.executeDeleteCache(sqlsentence, arguNameList, arguValueList);
				return updateCount;
			case UPDATE:
				if(setargunum == null) {
					setargunum = IMDGPreparedStatement.updateSetArguNumMap.get(sqlsentence);
				}
				if(updatesetArguList == null) {
					updatesetArguList = new ArrayList<String>(arguNameList.subList(0, setargunum));
					updatewhereArguList = new ArrayList<String>(arguNameList.subList(setargunum, arguNameList.size()));
				}
				ArrayList<String> updatesetValueList = new ArrayList<String>(arguValueList.subList(0, setargunum));
				ArrayList<String> updatewhereValueList = new ArrayList<String>(arguValueList.subList(setargunum, arguValueList.size()));
				updateCount = hzExecutor.executeUpdateCache(sqlsentence, updatesetArguList, updatesetValueList, updatewhereArguList, updatewhereValueList);
				return updateCount;
			default:
				throw new SQLException("Unknow SQL Type");
			}
		} else {
			String sql = SQLConcat();
			switch (sqlkind) {
			case INSERT:
				if (supportedornot) {
					updateCount = hzExecutor.executeInsertPre(sqlsentence, sql, hzrs);
					hzrs.checkResult();
				} else {
					DBExecuteInsert(sql);
				}
				return updateCount;
			case DELETE:
				if (supportedornot) {
					updateCount = hzExecutor.executeDeletePre(sqlsentence, sql);
				} else {
					DBExecuteDelete(sql);
				}
				return updateCount;
			case UPDATE:
				if (supportedornot) {
					updateCount = hzExecutor.executeUpdatePre(sqlsentence, sql);
				} else {
					DBExecuteUpdate(sql);
				}
				return updateCount;
			default:
				throw new SQLException("Unknow SQL Type");
			}
		}
	}
	
	public int executeUpdate(String sql) throws SQLException {
		// 閸掑攨nsert閵嗕菇pdate閵嗕龚elete閹垮秳缍旈幍褑顢�
		//IMDGLog.showInfo("executeUpdate string sql");
//		checkClosed();
//		clear();
//		sql = sql.toLowerCase();
//		switch (sqlkind) {
//		case SELECT:
//			throw new SQLException("No Search Allowed");
//		case INSERT:
//			if(hzrs == null) {
//				hzrs = new IMDGResultSet(this);
//			}
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeInsert(sql, hzrs);
//				hzrs.checkResult();
//			} else {
//				DBExecuteInsert(sql);
//			}
//			break;
//		case DELETE:
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeDelete(sql);
//			} else {
//				DBExecuteDelete(sql);
//			}
//			break;
//		case UPDATE:
//			if (hzExecutor.supportedUpdate(sql)) {
//				updateCount = hzExecutor.executeUpdate(sql);
//			} else {
//				DBExecuteUpdate(sql);
//			}
//			break;
//		default:
//			throw new SQLException("Unknow SQL Type");
//		}
//		return updateCount;
		throw new SQLException(" executeUpdate(String sql) Not Implemented.");
	}

	
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		//IMDGLog.showInfo("executeUpdate string sql int auto");
		throw new SQLException(" executeUpdate(String sql, int autoGeneratedKeys) Not Implemented.");
	}

	
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		// 鏉╂瑤閲滄径顏勵樉閺夊倷绨￠敍灞肩瑓娑擄拷澧楅崘宥堫嚛
		throw new SQLException("executeUpdate(String sql, int[] columnIndexes) Not Implemented.");
	}

	
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		// 鏉╂瑤閲滄径顏勵樉閺夊倷绨￠敍灞肩瑓娑擄拷澧楅崘宥堫嚛
		throw new SQLException("executeUpdate(String sql, String[] columnNames) Not Implemented.");
	}

	
	public Connection getConnection() throws SQLException {
		return this.connection;
	}

	
	public int getFetchDirection() throws SQLException {
		return java.sql.ResultSet.FETCH_FORWARD;
	}

	
	public int getFetchSize() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	
	public ResultSet getGeneratedKeys() throws SQLException {
		// 閼惧嘲褰囬悽鍙樼艾閹笛嗩攽濮濓拷Statement 鐎电钖勯懓灞藉灡瀵よ櫣娈戦幍锟芥箒閼奉亜濮╅悽鐔稿灇閻ㄥ嫰鏁�
		// 婵″倹鐏夊锟絊tatement 鐎电钖勫▽鈩冩箒閻㈢喐鍨氭禒璁崇秿闁款噯绱濋崚娆掔箲閸ョ偟鈹栭惃锟絉esultSet 鐎电钖勯妴锟�		// 濞夘煉绱版俊鍌涚亯閺堫亝瀵氱�姘炽�缁�缚鍤滈崝銊ф晸閹存劙鏁惃鍕灙閿涘苯鍨�JDBC 妞瑰崬濮╃粙瀣碍鐎圭偟骞囩亸鍡欌�鐎规碍娓堕懗鍊熴�缁�缚鍤滈崝銊ф晸閹存劙鏁惃鍕灙閵嗭拷
		// 鏉╂瑤閲滈崝鐔诲厴鐟曚焦鐪扮�閫涚艾閹绘帒鍙嗛幙宥勭稊閺傜増鍧婇崝鐘垫畱閸掓娓剁憰浣界箲閸ョ偠绻栨禍娑樺灙閻ㄥ嫪瀵岄柨顕嗙礉閻掕泛鎮楅弸鍕拷ResultSet
		// 鏉╂瑩鍣烽獮鑸电梾閺堝顔曠拋鈥崇暚閺佽揪绱濇潻姗�付鐟曚焦鍏傞崝鐐寸《鐏忓攰ey閻ㄥ嫬锟芥导鐘伙拷缂佹瑨绻栨禍娑橆嚠鐠烇拷
		// 閻╊喖澧犳潻娆庨嚋閻楀牊婀伴崣顏呮暜閹镐礁宕熼崚妞惧瘜闁款喚娈戦幆鍛枌
		if(!hzrs.isClosed())
			return hzrs;
		else if(!dbrs.isClosed()) {
			return dbrs;
		} else {
			throw new SQLException("No Available ResultSet");
		}
	}

	public int getMaxFieldSize() throws SQLException {
		// For Version 2
//		return fetchSize;
		return 0;
	}

	
	public int getMaxRows() throws SQLException {
//		return this.maxRows;
		return 0;
	}

	
	public ResultSetMetaData getMetaData() throws SQLException {
		// HashMap<Integer, String> colIndexMap need to be written by parsing sql statement
		// no supported yet
		// TODO
//		if (rsmd == null) {
//			rsmd = dbst.getMetaData();
//		}
//		return rsmd;
		return null;
	}
	
	public boolean getMoreResults() throws SQLException {
		// 鏉╂瑤閲滄稉宥堝厴婢剁喐鏁幐锟�		throw new SQLException("No Supported");
		return false;
	}
	
	
	public boolean getMoreResults(int current) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	
	public ParameterMetaData getParameterMetaData() throws SQLException {
		// no supported yet
		return new IMDGParametermetaData();
	}

	
	public int getQueryTimeout() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	
	public ResultSet getResultSet() throws SQLException {
		if(!hzrs.isClosed())
			return hzrs;
		else if(!dbrs.isClosed()) {
			return dbrs;
		} else {
			throw new SQLException("No Available ResultSet");
		}
	}

	
	public int getResultSetConcurrency() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	
	public int getResultSetHoldability() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	
	public int getResultSetType() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	
	public int getUpdateCount() throws SQLException {
		// 闂囷拷顪呴崷銊︽纯閺傜増鎼锋担婊勬閺囧瓨鏌�updateCount;
		return updateCount;
	}

	
	public SQLWarning getWarnings() throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	
	public boolean isClosed() throws SQLException {
		return closed;
	}

	
	public boolean isPoolable() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	
	private ArrayList<String> parseDeleteSQL(String sql) {
		return parseSelectSQL(sql);
	}

	
	private ArrayList<String> parseInsertSQL(String sql) {
		String str = sql.trim().split("[()]")[1];
		String[] values = str.trim().split("[, ]+");
		ArrayList<String> results = new ArrayList<String>();
		Collections.addAll(results, values);
		return results;
	}

	
	private ArrayList<String> parseSelectSQL(String sql) {
		ArrayList<String> values = new ArrayList<String>();
		ArrayList<String> results = new ArrayList<String>();
		String[] strs = sql.trim().split("'");
		int length = strs.length;
		for (int j = 0; j < length; j++) {
			if(j%2 == 0) {
				String[] tmps = strs[j].trim().split("[ ,()]+");
				for (String str : tmps) {
					//toLowerCase?
//					values.add(str.toLowerCase());
					values.add(str);
				}
			} else {
				values.add("'" + strs[j] + "'");
			}
		}
		length = values.size();
		for (int t = 0; t < length; t++) {
			if(values.get(t).equals("?")) {
				String name = values.get(t-2);
				int index = name.indexOf('.');
				if(index != -1) {
					results.add(name.substring(++index));
				} else {
					results.add(name);
				}
			}
		}
		return results;
	}

	
	private int parseUpdateSQL(String sql, ArrayList<String> outList) {
		ArrayList<String> tmp = parseSelectSQL(sql);
		int index = sql.toLowerCase().indexOf(" where ");
		int num = 0;
		int length = sql.length();
		for(;index < length; ++index) {
			if(sql.charAt(index) == '?') {
				++num;
			}
		}
		num = tmp.size() - num;
		outList.clear();
		outList.addAll(tmp);
		return num;
	}

	
	public void setArray(int parameterIndex, Array x) throws SQLException {
		throw new SQLException("No Implemented.");
		
	}

	
	public void setAsciiStream(int parameterIndex, InputStream x)
			throws SQLException {
		// most 1024 bytes
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
			return;
		}
		byte[] bytes = new byte[1025];
		try {
			x.read(bytes, 0, 1024);
		} catch (IOException e) {
			e.printStackTrace();
		}
		setString(parameterIndex, new String(bytes));
	}

	
	public void setAsciiStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		// different with MySQL
		// read from stream into a string
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
			return;
		}
		byte[] bytes = new byte[length + 1];
		try {
			x.read(bytes, 0, length);
		} catch (IOException e) {
			e.printStackTrace();
		}
		setString(parameterIndex, new String(bytes));
	}

	
	public void setAsciiStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		// same problem with the above
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
			return;
		}
		byte[] bytes = new byte[(int) (length+1L)];
		try {
			x.read(bytes, 0, (int) length);
		} catch (IOException e) {
			e.printStackTrace();
		}
		setString(parameterIndex, new String(bytes));
	}

	
	public void setBigDecimal(int parameterIndex, BigDecimal x)
			throws SQLException {
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setValue(parameterIndex, null);
		} else {
			setValue(parameterIndex, String.valueOf(x));
		}
	}

	
	public void setBinaryStream(int parameterIndex, InputStream x)
			throws SQLException {
		setAsciiStream(parameterIndex, x);
	}

	
	public void setBinaryStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		// same problem with the above
		setAsciiStream(parameterIndex, x, length);
	}

	public void setBinaryStream(int parameterIndex, InputStream x, long length)
			throws SQLException {
		setAsciiStream(parameterIndex, x, length);
	}

	
	public void setBlob(int parameterIndex, Blob x) throws SQLException {
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
		} else {
			setString(parameterIndex, new String(x.getBytes(0, (int)x.length())));
		}
	}

	
	public void setBlob(int parameterIndex, InputStream inputStream)
			throws SQLException {
		setAsciiStream(parameterIndex, inputStream);
	}

	
	public void setBlob(int parameterIndex, InputStream inputStream, long length)
			throws SQLException {
		setAsciiStream(parameterIndex, inputStream, length);
	}

	
	public void setBoolean(int parameterIndex, boolean x) throws SQLException {
		CheckParamIndex(parameterIndex);
		if(x) {
			setValue(parameterIndex, "true");
		} else {
			setValue(parameterIndex, "false");
		}
	}

	
	public void setByte(int parameterIndex, byte x) throws SQLException {
		CheckParamIndex(parameterIndex);
		setValue(parameterIndex, String.valueOf(x));
	}

	
	public void setBytes(int parameterIndex, byte[] x) throws SQLException {
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
		} else {
			setString(parameterIndex, new String(x));
		}
	}

	
	public void setCharacterStream(int parameterIndex, Reader reader)
			throws SQLException {
		// most 1024 bytes
		CheckParamIndex(parameterIndex);
		if (reader == null) {
			setValue(parameterIndex, null);
			return;
		}
		char[] buffer = new char[1025];
		try {
			reader.read(buffer, 0, 1024);
		} catch (IOException e) {
			e.printStackTrace();
		}
		setString(parameterIndex, new String(buffer));
	}

	
	public void setCharacterStream(int parameterIndex, Reader reader, int length)
			throws SQLException {
		// same problem with the above
		CheckParamIndex(parameterIndex);
		if (reader == null) {
			setString(parameterIndex, null);
			return;
		}
		char[] buffer = new char[length+1];
		try {
			reader.read(buffer, 0, length);
		} catch (IOException e) {
			e.printStackTrace();
		}
		setString(parameterIndex, new String(buffer));
	}

	
	public void setCharacterStream(int parameterIndex, Reader reader,
			long length) throws SQLException {
		setCharacterStream(parameterIndex, reader, (int)length);
	}

	public void setClob(int parameterIndex, Clob x) throws SQLException {
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
		} else {
			setString(parameterIndex, x.getSubString(1L, (int)x.length()));
		}
	}

	
	
	public void setClob(int parameterIndex, Reader reader) throws SQLException {
		setCharacterStream(parameterIndex, reader);
	}

	public void setClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		setCharacterStream(parameterIndex, reader, (int)length);
	}

	public void setCursorName(String name) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setDate(int parameterIndex, Date x) throws SQLException {
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
			return;
		} 
		SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd");
		setString(parameterIndex, dateFormatter.format(x));
	}

	public void setDate(int parameterIndex, Date x, Calendar cal)
			throws SQLException {
		setDate(parameterIndex, x);
	}

	public void setDouble(int parameterIndex, double x) throws SQLException {
		CheckParamIndex(parameterIndex);
		setValue(parameterIndex, String.valueOf(x));
	}

	public void setEscapeProcessing(boolean enable) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setFetchDirection(int direction) throws SQLException {
		switch (direction) {
		case java.sql.ResultSet.FETCH_FORWARD:
		case java.sql.ResultSet.FETCH_REVERSE:
		case java.sql.ResultSet.FETCH_UNKNOWN:
			break;

		default:
			throw new SQLException("SQL_STATE_ILLEGAL_ARGUMENT");
		}
		
	}

	public void setFetchSize(int rows) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setFloat(int parameterIndex, float x) throws SQLException {
		CheckParamIndex(parameterIndex);
		setValue(parameterIndex, String.valueOf(x));
//		parameterStrings[parameterIndex-1] = String.valueOf(x);
	}

	public void setInt(int parameterIndex, int x) throws SQLException {
		CheckParamIndex(parameterIndex);
		setValue(parameterIndex, String.valueOf(x));
	}

	public void setLong(int parameterIndex, long x) throws SQLException {
		CheckParamIndex(parameterIndex);
		setValue(parameterIndex, String.valueOf(x));
	}

	public void setMaxFieldSize(int max) throws SQLException {
		// For Version 2
//		if (max < 0) {
//			throw new SQLException("ilegal argument");
//		}
//		fetchSize = max;
	}

	public void setMaxRows(int max) throws SQLException {
//		if (max <= 0) {
//			throw new SQLException("ilegal argument");
//		}
//		maxRows = max;
	}

	public void setNCharacterStream(int parameterIndex, Reader value)
			throws SQLException {
		setCharacterStream(parameterIndex, value);
	}

	public void setNCharacterStream(int parameterIndex, Reader value,
			long length) throws SQLException {
		setCharacterStream(parameterIndex, value, (int)length);		
	}

	public void setNClob(int parameterIndex, NClob value) throws SQLException {
		// no supported yet
		throw new SQLException("No Implemented.");
	}

	public void setNClob(int parameterIndex, Reader reader) throws SQLException {
		setCharacterStream(parameterIndex, reader);
	}

	public void setNClob(int parameterIndex, Reader reader, long length)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setNString(int parameterIndex, String value)
			throws SQLException {
		setString(parameterIndex, value);
	}

	public void setNull(int parameterIndex, int sqlType) throws SQLException {
		CheckParamIndex(parameterIndex);
		setValue(parameterIndex, null);
	}

	public void setNull(int parameterIndex, int sqlType, String typeName)
			throws SQLException {
		setNull(parameterIndex, sqlType);
	}

	//TODO: datatype 集中管理
	public void setObject(int parameterIndex, Object x) throws SQLException {
		if (x == null) {
			setNull(parameterIndex, java.sql.Types.OTHER);
		} else {
			if (x instanceof Byte) {
				setInt(parameterIndex, ((Byte) x).intValue());
			} else if (x instanceof String) {
				setString(parameterIndex, (String) x);
			} else if (x instanceof BigDecimal) {
				setBigDecimal(parameterIndex, (BigDecimal) x);
			} else if (x instanceof Short) {
				setShort(parameterIndex, ((Short) x).shortValue());
			} else if (x instanceof Integer) {
				setInt(parameterIndex, ((Integer) x).intValue());
			} else if (x instanceof Long) {
				setLong(parameterIndex, ((Long) x).longValue());
			} else if (x instanceof Float) {
				setFloat(parameterIndex, ((Float) x).floatValue());
			} else if (x instanceof Double) {
				setDouble(parameterIndex, ((Double) x).doubleValue());
			} else if (x instanceof byte[]) {
				setBytes(parameterIndex, (byte[]) x);
			} else if (x instanceof java.sql.Date) {
				setDate(parameterIndex, (java.sql.Date) x);
			} else if (x instanceof Time) {
				setTime(parameterIndex, (Time) x);
			} else if (x instanceof Timestamp) {
				setTimestamp(parameterIndex, (Timestamp) x);
			} else if (x instanceof Boolean) {
				setBoolean(parameterIndex, ((Boolean) x)
						.booleanValue());
			} else if (x instanceof InputStream) {
				setBinaryStream(parameterIndex, (InputStream) x, -1);
			} else if (x instanceof java.sql.Blob) {
				setBlob(parameterIndex, (java.sql.Blob) x);
			} else if (x instanceof java.sql.Clob) {
				setClob(parameterIndex, (java.sql.Clob) x);
			} else if (x instanceof java.util.Date) {
				setTimestamp(parameterIndex, new Timestamp(((java.util.Date) x).getTime()));
			} else if (x instanceof BigInteger) {
				setString(parameterIndex, x.toString());
			} else {
				setSerializableObject(parameterIndex, x);
			}
		}
	}

	public void setObject(int parameterIndex, Object x, int targetSqlType)
			throws SQLException {
		setObject(parameterIndex, x);
	}

	public void setObject(int parameterIndex, Object x, int targetSqlType,
			int scaleOrLength) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setPoolable(boolean poolable) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setQueryTimeout(int seconds) throws SQLException {
		// TODO Auto-generated method stub
		
	}

	void setReadOnly(boolean isReadOnly) {
		this.isReadOnly = isReadOnly;
	}

	public void setRef(int parameterIndex, Ref x) throws SQLException {
			throw new SQLException("No Implemented.");
	}

	void setResultSetConcurrency(int resultSetConcurrency) {
		this.resultSetConcurrency = resultSetConcurrency;
	}

	void setResultSetType(int resultSetType) {
		this.resultSetType = resultSetType;
	}

	public void setRowId(int parameterIndex, RowId x) throws SQLException {
		// no supported yet
		throw new SQLException("No Implemented.");
	}

	private final void setSerializableObject(int parameterIndex,
			Object parameterObj) throws SQLException {
		try {
			ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
			ObjectOutputStream objectOut = new ObjectOutputStream(bytesOut);
			objectOut.writeObject(parameterObj);
			objectOut.flush();
			objectOut.close();
			bytesOut.flush();
			bytesOut.close();

			byte[] buf = bytesOut.toByteArray();
			ByteArrayInputStream bytesIn = new ByteArrayInputStream(buf);
			setBinaryStream(parameterIndex, bytesIn, buf.length);
		} catch (Exception ex) {
			throw new SQLException(ex.getMessage());
		}
	}

	public void setShort(int parameterIndex, short x) throws SQLException {
		CheckParamIndex(parameterIndex);
		setValue(parameterIndex, String.valueOf(x));
	}

	public void setSQLXML(int parameterIndex, SQLXML xmlObject)
			throws SQLException {
		// TODO Auto-generated method stub
		
	}

	public void setString(int parameterIndex, String x) throws SQLException {
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setValue(parameterIndex, null);
			return;
		} else {
			//toLowerCase?
			//arguValueList.set(parameterIndex - 1, "'" + x.toLowerCase() + "'");
			arguValueList.set(parameterIndex - 1, "'" + x + "'");
		}
	}

	public void setTime(int parameterIndex, Time x) throws SQLException {
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
			return;
		}
		setString(parameterIndex, x.toString());
	}

	public void setTime(int parameterIndex, Time x, Calendar cal)
			throws SQLException {
		setTime(parameterIndex, x);
	}

	public void setTimestamp(int parameterIndex, Timestamp x)
			throws SQLException {
		CheckParamIndex(parameterIndex);
		if (x == null) {
			setString(parameterIndex, null);
			return;
		}
		DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
		String time1 = formatter.format(x);
		setString(parameterIndex, time1);
	}

	public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal)
			throws SQLException {
		setTimestamp(parameterIndex, x);
	}

	public void setUnicodeStream(int parameterIndex, InputStream x, int length)
			throws SQLException {
		setAsciiStream(parameterIndex, x, length);
	}

	public void setURL(int parameterIndex, URL x) throws SQLException {
		if (x != null) {
			setString(parameterIndex, x.toString());
		} else {
			setNull(parameterIndex, Types.CHAR);
		}
	}
	
	private void setValue(int parameterIndex, String value) {
			if(value == null) {
				arguValueList.set(parameterIndex - 1, "null");
			} else {
				arguValueList.set(parameterIndex - 1, value);
			}
	}

	private String SQLConcat() {
		StringBuffer buffer = new StringBuffer(originalSql[0]);
		if(arguValueList.size() > 0) {
			int len = arguValueList.size();
			for(int i = 0; i < len; ++i) {
				buffer.append(arguValueList.get(i));
				buffer.append(originalSql[i+1]);
			}
		}
		//toLowerCase?
		//return buffer.toString().trim().toLowerCase();
//		String sql = buffer.toString().trim();
//		System.out.println("sqlConcat:" + sql);
		return buffer.toString().trim();
	}

	public <T> T unwrap(Class<T> iface) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}
	
	
	//TODO: hzrs here is for what?
	class ExecuteBatchSubTask implements Runnable {
		
		private int i;
		public ExecuteBatchSubTask(int i){
			this.i = i;
		}
		public void run(){
			ArrayList<String> batchValueList = null;
			switch(sqlkind){
			//TODO: primaryKey is null, autoGenerated primarykey(mysql)
			case INSERT:
				for(int j = 1 + i*blockSize; j <= (i+1)*blockSize; j++){
					try {
						batchValueList = arguValueListMap.get(IMDGString.BATCHKEY + j);
						if (batchValueList == null) {
							continue;
						}
						hzExecutor.executeInsertCache(sqlsentence, arguNameList, batchValueList, hzrs);
					} catch (SQLException e) {
						e.printStackTrace();
					}
				}
				break;
			case DELETE:
				for(int j = 1 + i*blockSize; j <= (i+1)*blockSize; j++){
					try {
						batchValueList = arguValueListMap.get(IMDGString.BATCHKEY + j);
						if (batchValueList == null) {
							break;
						}
						hzExecutor.executeDeleteCache(sqlsentence, arguNameList, batchValueList);
					} catch (SQLException e) {
						e.printStackTrace();
					}
				}
				break;
			case UPDATE:
				if(setargunum == null) {
					setargunum = IMDGPreparedStatement.updateSetArguNumMap.get(sqlsentence);
				}
				if(updatesetArguList == null) {
					updatesetArguList = new ArrayList<String>(arguNameList.subList(0, setargunum));
					updatewhereArguList = new ArrayList<String>(arguNameList.subList(setargunum, arguNameList.size()));
				}
				for(int j = 1 + i*blockSize; j <= (i+1)*blockSize; j++){
					try {
						batchValueList = arguValueListMap.get(IMDGString.BATCHKEY + j);
						if (batchValueList == null) {
							break;
						}
						ArrayList<String> updatesetValueList = new ArrayList<String>(batchValueList.subList(0, setargunum));
						ArrayList<String> updatewhereValueList = new ArrayList<String>(batchValueList.subList(setargunum, batchValueList.size()));
						hzExecutor.executeUpdateCache(sqlsentence, updatesetArguList, updatesetValueList, updatewhereArguList, updatewhereValueList);
					} catch (SQLException e) {
						e.printStackTrace();
					}
				}
				break;
			default:
				try {
					throw new SQLException("Unknow SQL Type");
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			
		}
	}
}
